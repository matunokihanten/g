<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <!-- ズーム無効化・固定のためのmetaタグ -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <!-- Google Fonts: Noto Sans JP -->
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP&display=swap" rel="stylesheet">
  <title>シンプル迷路ゲーム</title>
  <style>
    /* 全体の背景とフォント */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: linear-gradient(to bottom, #74ebd5, #ACB6E5);
      font-family: 'Noto Sans JP', sans-serif;
      touch-action: manipulation;
    }
    /* ゲーム全体のコンテナ：幅100%、最大800px、中央寄せ */
    /* transform はJSで更新するため初期値を与える */
    #gameContainer {
      width: 100%;
      max-width: 800px;
      margin: 30px auto;
      transform-origin: top center;
      /* 初期は90%に縮小（10%縮小） */
      transform: scale(0.9);
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: rgba(255,255,255,0.92);
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    /* ズーム操作用コントロール（上部に配置） */
    #zoomControls {
      margin-bottom: 20px;
    }
    #zoomControls button {
      margin: 0 10px;
      font-size: 16px;
      background-color: #4CAF50;
      color: #fff;
      border: none;
      border-radius: 8px;
      padding: 10px 20px;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      transition: background-color 0.2s;
    }
    #zoomControls button:hover {
      background-color: #45a049;
    }
    /* キャンバス：HTML属性で800×800、CSSでレスポンシブ表示 */
    canvas {
      width: 100%;
      height: auto;
      background: #fff;
      border: 2px solid #333;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      border-radius: 8px;
    }
    /* 操作パネル */
    #controls {
      margin-top: 20px;
      text-align: center;
      width: 100%;
    }
    .control-group {
      margin: 10px;
    }
    /* スライダーおよびラベル */
    #difficultySlider {
      width: 250px;
      margin-right: 10px;
      vertical-align: middle;
    }
    #difficultyLabel {
      font-size: 16px;
      vertical-align: middle;
    }
    /* 共通のボタンスタイル */
    button {
      background-color: #4CAF50;
      color: #fff;
      border: none;
      border-radius: 8px;
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      transition: background-color 0.2s;
    }
    button:hover {
      background-color: #45a049;
    }
    /* 十字キー領域 */
    #dpad {
      margin-top: 20px;
      display: grid;
      grid-template-columns: 100px 100px 100px;
      grid-template-rows: 100px 100px 100px;
      grid-template-areas: 
        ". up ."
        "left . right"
        ". down .";
      gap: 10px;
      justify-content: center;
      width: 100%;
    }
    /* 配置指定 */
    #upBtn { grid-area: up; }
    #downBtn { grid-area: down; }
    #leftBtn { grid-area: left; }
    #rightBtn { grid-area: right; }
    /* 十字キー用ボタン */
    #dpad button {
      width: 100%;
      height: 100%;
      font-size: 28px;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <!-- ズーム操作用ボタンを迷路の上部に表示 -->
    <div class="control-group" id="zoomControls">
      <button id="zoomOutBtn">ズームアウト</button>
      <button id="zoomInBtn">ズームイン</button>
    </div>
    <!-- 迷路描画用キャンバス (800×800px) -->
    <canvas id="mazeCanvas" width="800" height="800"></canvas>
    <!-- 操作パネル -->
    <div id="controls">
      <div class="control-group">
        <input type="range" id="difficultySlider" min="1" max="100" value="1">
        <span id="difficultyLabel">Difficulty: 1 (5x5)</span>
        <button id="newMazeBtn">新しい迷路</button>
        <button id="autoSolveBtn">答え</button>
      </div>
      <div class="control-group" id="dpad">
        <button id="upBtn">↑</button>
        <button id="leftBtn">←</button>
        <button id="rightBtn">→</button>
        <button id="downBtn">↓</button>
      </div>
    </div>
  </div>
  <script>
    // ────────────── グローバル変数 ──────────────
    const canvas = document.getElementById('mazeCanvas');
    const ctx = canvas.getContext('2d');
    const gameContainer = document.getElementById('gameContainer');
    let grid = [];
    let rows = 5, cols = 5;              // 初期は5×5のグリッド
    let cellSize = canvas.width / cols;  // セル1つあたりのサイズ
    let currentCell = null;
    let stack = [];                      // DFS用スタック
    let manualTrail = [];                // 手動移動経路（青）
    let autoTrail = [];                  // 自動解答経路（赤）
    let autoSolutionPath = [];           // BFSで計算した最短経路
    let autoSolving = false;             // 自動解答中フラグ
    let autoStepDelay = 200;             // 自動解答時の移動間隔（ミリ秒）
    let lastAutoMoveTime = 0;
    let autoIndex = 0;
    let difficulty = 1;                  // 現在の難易度
    // ズームレベル（初期は0.9＝10%縮小）
    let zoomLevel = 0.9;

    // ────────────── UI 要素 ──────────────
    const difficultySlider = document.getElementById('difficultySlider');
    const difficultyLabel = document.getElementById('difficultyLabel');
    const newMazeBtn = document.getElementById('newMazeBtn');
    const autoSolveBtn = document.getElementById('autoSolveBtn');
    const upBtn = document.getElementById('upBtn');
    const downBtn = document.getElementById('downBtn');
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    const zoomInBtn = document.getElementById('zoomInBtn');
    const zoomOutBtn = document.getElementById('zoomOutBtn');

    // ────────────── タッチ/クリックイベントのユーティリティ ──────────────
    function addButtonListener(el, callback) {
      el.addEventListener('click', callback);
      el.addEventListener('touchstart', function(e) {
        e.preventDefault();
        callback();
      }, { passive: false });
    }

    // ズーム更新用関数
    function updateZoom() {
      gameContainer.style.transform = "scale(" + zoomLevel + ")";
    }

    // ────────────── セルオブジェクトと迷路生成 ──────────────
    function Cell(row, col) {
      this.row = row;
      this.col = col;
      this.walls = { top: true, right: true, bottom: true, left: true };
      this.visited = false;
    }

    function getUnvisitedNeighbors(cell) {
      const neighbors = [];
      const { row, col } = cell;
      if (row > 0 && !grid[row - 1][col].visited) neighbors.push(grid[row - 1][col]);
      if (col < cols - 1 && !grid[row][col + 1].visited) neighbors.push(grid[row][col + 1]);
      if (row < rows - 1 && !grid[row + 1][col].visited) neighbors.push(grid[row + 1][col]);
      if (col > 0 && !grid[row][col - 1].visited) neighbors.push(grid[row][col - 1]);
      return neighbors;
    }

    function removeWalls(current, next) {
      let x = current.col - next.col;
      let y = current.row - next.row;
      if (x === 1) {
        current.walls.left = false;
        next.walls.right = false;
      } else if (x === -1) {
        current.walls.right = false;
        next.walls.left = false;
      }
      if (y === 1) {
        current.walls.top = false;
        next.walls.bottom = false;
      } else if (y === -1) {
        current.walls.bottom = false;
        next.walls.top = false;
      }
    }

    function generateMaze() {
      grid = [];
      stack = [];
      manualTrail = [];
      autoTrail = [];
      autoSolutionPath = [];
      autoSolving = false;
      autoIndex = 0;
      
      // 難易度スライダーの値に合わせたグリッドサイズ：難易度1→5×5、難易度100→約100×100
      cols = rows = Math.floor(5 + ((difficulty - 1) / 99) * 95);
      cellSize = canvas.width / cols;
      
      for (let r = 0; r < rows; r++) {
        grid[r] = [];
        for (let c = 0; c < cols; c++) {
          grid[r][c] = new Cell(r, c);
        }
      }
      
      currentCell = grid[0][0];
      currentCell.visited = true;
      manualTrail.push(getCellCenter(currentCell));
      
      stack.push(currentCell);
      while (stack.length > 0) {
        let current = stack[stack.length - 1];
        let neighbors = getUnvisitedNeighbors(current);
        if (neighbors.length > 0) {
          let next = neighbors[Math.floor(Math.random() * neighbors.length)];
          next.visited = true;
          removeWalls(current, next);
          stack.push(next);
        } else {
          stack.pop();
        }
      }
    }

    function getCellCenter(cell) {
      return {
        x: cell.col * cellSize + cellSize / 2,
        y: cell.row * cellSize + cellSize / 2
      };
    }

    // ────────────── 描画関数 ──────────────
    function drawMaze() {
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2;
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const cell = grid[r][c];
          const x = c * cellSize;
          const y = r * cellSize;
          if (cell.walls.top) {
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + cellSize, y);
            ctx.stroke();
          }
          if (cell.walls.right) {
            ctx.beginPath();
            ctx.moveTo(x + cellSize, y);
            ctx.lineTo(x + cellSize, y + cellSize);
            ctx.stroke();
          }
          if (cell.walls.bottom) {
            ctx.beginPath();
            ctx.moveTo(x + cellSize, y + cellSize);
            ctx.lineTo(x, y + cellSize);
            ctx.stroke();
          }
          if (cell.walls.left) {
            ctx.beginPath();
            ctx.moveTo(x, y + cellSize);
            ctx.lineTo(x, y);
            ctx.stroke();
          }
        }
      }
    }

    function drawGoal() {
      ctx.fillStyle = 'red';
      ctx.fillRect((cols - 1) * cellSize + 2, (rows - 1) * cellSize + 2, cellSize - 4, cellSize - 4);
    }

    function drawManualTrail() {
      if (manualTrail.length < 2) return;
      ctx.strokeStyle = 'blue';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(manualTrail[0].x, manualTrail[0].y);
      for (let i = 1; i < manualTrail.length; i++) {
        ctx.lineTo(manualTrail[i].x, manualTrail[i].y);
      }
      ctx.stroke();
    }

    function drawAutoTrail() {
      if (autoTrail.length < 2) return;
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(autoTrail[0].x, autoTrail[0].y);
      for (let i = 1; i < autoTrail.length; i++) {
        ctx.lineTo(autoTrail[i].x, autoTrail[i].y);
      }
      ctx.stroke();
    }

    function drawPlayer() {
      let center = getCellCenter(currentCell);
      ctx.fillStyle = 'blue';
      let headRadius = cellSize * 0.2;
      // 頭（円）
      ctx.beginPath();
      ctx.arc(center.x, center.y - headRadius, headRadius, 0, Math.PI * 2);
      ctx.fill();
      // 体（線）
      ctx.beginPath();
      ctx.moveTo(center.x, center.y);
      ctx.lineTo(center.x, center.y + headRadius * 2);
      ctx.strokeStyle = 'blue';
      ctx.lineWidth = 3;
      ctx.stroke();
    }

    function gameLoop(timestamp) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawMaze();
      drawGoal();
      drawManualTrail();
      drawAutoTrail();
      drawPlayer();
      if (autoSolving) {
        updateAutoSolve(timestamp);
      }
      requestAnimationFrame(gameLoop);
    }

    function updateAutoSolve(timestamp) {
      if (!lastAutoMoveTime) lastAutoMoveTime = timestamp;
      if (timestamp - lastAutoMoveTime > autoStepDelay && autoIndex < autoSolutionPath.length) {
        currentCell = autoSolutionPath[autoIndex];
        autoTrail.push(getCellCenter(currentCell));
        manualTrail.push(getCellCenter(currentCell));
        autoIndex++;
        lastAutoMoveTime = timestamp;
        if (autoIndex >= autoSolutionPath.length) {
          autoSolving = false;
        }
      }
    }

    // 壁がない場合、指定方向へ移動
    function movePlayer(direction) {
      if (autoSolving) return;
      let nextCell = null;
      const { row, col } = currentCell;
      if (direction === 'up' && !currentCell.walls.top && row > 0) {
        nextCell = grid[row - 1][col];
      } else if (direction === 'right' && !currentCell.walls.right && col < cols - 1) {
        nextCell = grid[row][col + 1];
      } else if (direction === 'down' && !currentCell.walls.bottom && row < rows - 1) {
        nextCell = grid[row + 1][col];
      } else if (direction === 'left' && !currentCell.walls.left && col > 0) {
        nextCell = grid[row][col - 1];
      }
      if (nextCell) {
        currentCell = nextCell;
        manualTrail.push(getCellCenter(currentCell));
      }
    }

    function autoSolve() {
      autoSolutionPath = [];
      autoTrail = [];
      autoIndex = 0;
      autoSolving = false;

      let start = currentCell;
      let goal = grid[rows - 1][cols - 1];
      let queue = [];
      let cameFrom = new Map();

      queue.push(start);
      cameFrom.set(start, null);

      while (queue.length > 0) {
        let current = queue.shift();
        if (current === goal) break;
        const { row, col } = current;
        let neighbors = [];
        if (!current.walls.top && row > 0) neighbors.push(grid[row - 1][col]);
        if (!current.walls.right && col < cols - 1) neighbors.push(grid[row][col + 1]);
        if (!current.walls.bottom && row < rows - 1) neighbors.push(grid[row + 1][col]);
        if (!current.walls.left && col > 0) neighbors.push(grid[row][col - 1]);
        for (let neighbor of neighbors) {
          if (!cameFrom.has(neighbor)) {
            queue.push(neighbor);
            cameFrom.set(neighbor, current);
          }
        }
      }

      let path = [];
      let current = goal;
      while (current !== null) {
        path.push(current);
        current = cameFrom.get(current);
      }
      path.reverse();
      autoSolutionPath = path;
      if (autoSolutionPath.length > 0) {
        autoSolving = true;
        autoTrail.push(getCellCenter(currentCell));
        lastAutoMoveTime = 0;
        autoIndex = 1;
      }
    }

    difficultySlider.addEventListener('input', function() {
      difficulty = parseInt(this.value);
      const gridSize = Math.floor(5 + ((difficulty - 1) / 99) * 95);
      difficultyLabel.textContent = `Difficulty: ${difficulty} (${gridSize}x${gridSize})`;
    });

    addButtonListener(newMazeBtn, generateMaze);
    addButtonListener(autoSolveBtn, autoSolve);
    addButtonListener(upBtn, () => movePlayer('up'));
    addButtonListener(downBtn, () => movePlayer('down'));
    addButtonListener(leftBtn, () => movePlayer('left'));
    addButtonListener(rightBtn, () => movePlayer('right'));

    addButtonListener(zoomInBtn, () => {
      zoomLevel += 0.1;  // 10%拡大
      updateZoom();
    });
    addButtonListener(zoomOutBtn, () => {
      zoomLevel = Math.max(0.1, zoomLevel - 0.1);  // 10%縮小（下限は0.1）
      updateZoom();
    });

    window.addEventListener('keydown', function(e) {
      if (e.key === 'ArrowUp') movePlayer('up');
      else if (e.key === 'ArrowRight') movePlayer('right');
      else if (e.key === 'ArrowDown') movePlayer('down');
      else if (e.key === 'ArrowLeft') movePlayer('left');
    });

    // 初期化してゲーム開始および初期ズーム設定
    generateMaze();
    updateZoom();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>