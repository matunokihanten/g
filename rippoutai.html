<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>
    動く立体オブジェクト認識チャレンジ
    （グリッド版 - 滑らか動作・3列表示・ズーム調整・豪華立方体・移動＆衝突回避・表示角度調整）
  </title>
  <!-- モバイル向けビューポート設定 -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background-color: #000;
      font-family: Arial, sans-serif;
    }
    canvas { display: block; }
    /* オーバーレイ：画面上部の情報・ズーム・表示角度調整 */
    #overlay {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255,255,255,0.85);
      padding: 10px;
      border-radius: 4px;
      z-index: 10;
    }
    #overlay button {
      padding: 6px 10px;
      font-size: 14px;
      margin-top: 8px;
    }
    #zoomControl, #angleControl { margin-top: 8px; }
    /* ※ 画面の向きに関するオーバーレイは削除しています */
  </style>
</head>
<body>
  <!-- オーバーレイ：ゲーム情報、ズーム調整、表示角度調整 -->
  <div id="overlay">
    <div id="instruction">一番赤い面が多い立方体をタップしてください。</div>
    <div id="status">
      <span id="round">ラウンド: 1</span> ｜ 
      <span id="score">スコア: 0</span>
    </div>
    <div id="message"></div>
    <div id="zoomControl">
      <label for="zoomSlider">ズーム調整: </label>
      <input type="range" id="zoomSlider" min="0.2" max="1.0" value="0.5" step="0.01">
    </div>
    <div id="angleControl">
      <label for="angleSlider">表示角度調整: </label>
      <!-- -180° ～ 180° の範囲。初期値 0° -->
      <input type="range" id="angleSlider" min="-180" max="180" value="0" step="1">
    </div>
    <button id="restartBtn" style="display:none;">スタートから挑戦する</button>
  </div>
  
  <!-- Three.js ライブラリ -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
  <script>
    // シーン、カメラ、レンダラーの初期設定
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x202020);
    
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.zoom = 0.5; // 初期はズームアウト状態（立方体が小さく写る）
    camera.updateProjectionMatrix();
    camera.position.set(0, 5, 20);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    
    // 照明設定
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 20, 10);
    scene.add(directionalLight);
    
    // ゲーム変数
    let cubes = [];         // 各ラウンドで配置される立方体群
    let correctCube = null; // 正解の立方体
    let score = 0;
    let round = 1;
    const baseCubeCount = 4;
    let gameIsRunning = false;
    
    const overlayMessage = document.getElementById('message');
    const roundDisplay   = document.getElementById('round');
    const scoreDisplay   = document.getElementById('score');
    const restartBtn     = document.getElementById('restartBtn');
    
    // ズーム調整用スライダー
    const zoomSlider = document.getElementById('zoomSlider');
    zoomSlider.addEventListener('input', () => {
      camera.zoom = parseFloat(zoomSlider.value);
      camera.updateProjectionMatrix();
    });
    
    // 表示角度調整用スライダー（角度は度数、グローバル変数 displayAngle にラジアンで保持）
    let displayAngle = 0;
    const angleSlider = document.getElementById('angleSlider');
    angleSlider.addEventListener('input', (event) => {
      let deg = parseFloat(event.target.value);
      displayAngle = THREE.MathUtils.degToRad(deg);
    });
    
    // Raycaster（タップ判定用）
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    
    // 利用する色（赤以外）
    const colors = ['blue', 'green', 'yellow', 'purple', 'orange'];
    
    // グリッド境界用global変数―各ラウンド開始時に設定
    let gridXMin, gridXMax, gridZMin, gridZMax;
    const margin = 2;  // 余裕をもたせる
    
    /**
     * 立方体作成関数
     * 指定枚数を赤に設定し、それ以外はランダムな色の豪華な質感を MeshPhysicalMaterial で表現します。
     * さらに透明なヒットボックスを追加してタップ補助も実装。
     */
    function createCube(redFaces) {
      const materials = [];
      const redIndices = [];
      while (redIndices.length < redFaces) {
        const idx = Math.floor(Math.random() * 6);
        if (!redIndices.includes(idx)) { redIndices.push(idx); }
      }
      for (let i = 0; i < 6; i++) {
        const color = redIndices.includes(i) ? 'red' : colors[Math.floor(Math.random() * colors.length)];
        materials.push(new THREE.MeshPhysicalMaterial({
          color: color,
          metalness: 0.8,
          roughness: 0.3,
          clearcoat: 1.0,
          clearcoatRoughness: 0.1,
          emissive: 0x000000
        }));
      }
      const geometry = new THREE.BoxGeometry(4, 4, 4);
      const cube = new THREE.Mesh(geometry, materials);
      
      // アニメーション用パラメータ
      cube.userData = {
        redCount: redFaces,
        rotationSpeed: 0.01 + Math.random() * 0.01,
        bounceAmplitude: 2 + Math.random() * 2,  // 2～4 の範囲
        bounceSpeed: 0.002 + Math.random() * 0.002,
        baseY: 0
      };
      // 透明なヒットボックス（20%拡大）を追加
      const scaleFactor = 1.2;
      const hitboxGeometry = new THREE.BoxGeometry(4 * scaleFactor, 4 * scaleFactor, 4 * scaleFactor);
      const hitboxMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, opacity: 0, transparent: true });
      const hitbox = new THREE.Mesh(hitboxGeometry, hitboxMaterial);
      hitbox.name = "hitbox";
      cube.add(hitbox);
      
      return cube;
    }
    
    /**
     * 新しいラウンド開始関数
     * グリッド（3列）上に立方体を配置し、各立方体の基準位置（baseX, baseZ）を保存します。
     * さらに、グリッド全体の端（X軸、Z軸）を計算して global 変数に設定します。
     * 各立方体には、X/Z軸方向の移動パラメータも設定します。
     */
    function startNewRound() {
      // 既存の立方体をすべて除去
      cubes.forEach(cube => scene.remove(cube));
      cubes = [];
      
      const numCubes = baseCubeCount + round - 1;
      const columns = 3;
      const rows = Math.ceil(numCubes / columns);
      const spacing = 8;
      const startX = -((columns - 1) * spacing) / 2;
      const startZ = -((rows - 1) * spacing) / 2;
      
      // グリッド境界の設定（各側に margin の余裕）
      gridXMin = startX + margin;
      gridXMax = startX + (columns - 1) * spacing - margin;
      gridZMin = startZ + margin;
      gridZMax = startZ + (rows - 1) * spacing - margin;
      
      // 正解立方体の決定
      const correctIndex = Math.floor(Math.random() * numCubes);
      const correctRedCount = Math.floor(Math.random() * 4) + 3;
      
      for (let i = 0; i < numCubes; i++) {
        const redCount = (i === correctIndex) ? correctRedCount : Math.floor(Math.random() * (correctRedCount - 1)) + 1;
        const cube = createCube(redCount);
        const col = i % columns;
        const rowIndex = Math.floor(i / columns);
        cube.position.x = startX + col * spacing;
        cube.position.z = startZ + rowIndex * spacing;
        // 保存：各立方体の基準位置
        cube.userData.baseX = cube.position.x;
        cube.userData.baseZ = cube.position.z;
        // X/Z軸の移動振幅を大きめに（4～7の範囲）
        cube.userData.xAmplitude = 4 + Math.random() * 3;
        cube.userData.xSpeed = 0.0005 + Math.random() * 0.001;
        cube.userData.xPhase = Math.random() * Math.PI * 2;
        cube.userData.zAmplitude = 4 + Math.random() * 3;
        cube.userData.zSpeed = 0.0005 + Math.random() * 0.001;
        cube.userData.zPhase = Math.random() * Math.PI * 2;
        
        // 各立方体の初回の回転角度（Y軸）を保存（表示角度調整用）
        cube.userData.baseRotationY = cube.rotation.y;
        
        cubes.push(cube);
        scene.add(cube);
      }
      
      correctCube = cubes[correctIndex];
      roundDisplay.innerText = "ラウンド: " + round;
      
      // カメラ位置の自動調整（グリッド全体が見渡せるように）
      const gridHeight = (rows - 1) * spacing;
      const newZ = Math.max(20, gridHeight + 10);
      const newY = Math.max(5, gridHeight / 2 + 2);
      camera.position.set(0, newY, newZ);
      camera.lookAt(0, 0, 0);
    }
    
    /**
     * 不正解時の処理
     * 正解の立方体の emissive 色を緑に変更し、一時的にスケールアップして強調表示します。
     * オーバーレイに正解情報を表示後、ラウンドを1段階下げて次のラウンドへ進みます。
     */
    function handleIncorrect() {
      gameIsRunning = false;
      if (correctCube) {
        if (Array.isArray(correctCube.material)) {
          correctCube.material.forEach(mat => {
            if (mat.emissive) { mat.emissive.set(0x00ff00); }
          });
        } else {
          if (correctCube.material.emissive) { correctCube.material.emissive.set(0x00ff00); }
        }
        // 正解立方体を大きくして強調表示
        correctCube.scale.set(1.3, 1.3, 1.3);
      }
      overlayMessage.innerText = "不正解！ 正解の立方体が緑に光っています。（赤面 " + correctCube.userData.redCount + " 枚）\nレベルを下げます。";
      if (round > 1) { round--; }
      roundDisplay.innerText = "ラウンド: " + round;
      setTimeout(() => {
        if (correctCube) { correctCube.scale.set(1, 1, 1); }
        gameIsRunning = true;
        startNewRound();
      }, 1500);
    }
    
    // タップ（クリック）判定
    window.addEventListener('click', (event) => {
      if (!gameIsRunning) return;
      
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(cubes, true);
      
      if (intersects.length > 0) {
        let selectedCube = intersects[0].object;
        if (selectedCube.name === "hitbox" && selectedCube.parent) {
          selectedCube = selectedCube.parent;
        }
        if (selectedCube === correctCube) {
          score++;
          scoreDisplay.innerText = "スコア: " + score;
          overlayMessage.innerText = "正解！ +1 ポイント";
          round++;
          gameIsRunning = false;
          setTimeout(() => { gameIsRunning = true; startNewRound(); }, 1000);
        } else {
          handleIncorrect();
        }
      }
    });
    
    // アニメーションループ（各立方体の滑らかな移動と表示角度調整）
    function animate() {
      requestAnimationFrame(animate);
      const elapsed = Date.now();
      cubes.forEach(cube => {
        // 回転
        cube.rotation.x += cube.userData.rotationSpeed;
        // Y軸回転：基準回転値に displayAngle を加える
        if (cube.userData.baseRotationY === undefined) {
          cube.userData.baseRotationY = cube.rotation.y;
        }
        cube.userData.baseRotationY += cube.userData.rotationSpeed;
        cube.rotation.y = cube.userData.baseRotationY + displayAngle;
        
        // Y軸バウンド: ターゲット値へ滑らかに更新
        const targetY = cube.userData.baseY + cube.userData.bounceAmplitude * Math.sin(elapsed * cube.userData.bounceSpeed);
        cube.position.y = THREE.MathUtils.lerp(cube.position.y, targetY, 0.05);
        
        // X/Z軸: 目標位置の計算と lerp による更新
        const targetX = cube.userData.baseX + cube.userData.xAmplitude * Math.sin(elapsed * cube.userData.xSpeed + cube.userData.xPhase);
        const targetZ = cube.userData.baseZ + cube.userData.zAmplitude * Math.cos(elapsed * cube.userData.zSpeed + cube.userData.zPhase);
        cube.position.x = THREE.MathUtils.lerp(cube.position.x, targetX, 0.05);
        cube.position.z = THREE.MathUtils.lerp(cube.position.z, targetZ, 0.05);
      });
      
      // 衝突回避：複数回反発処理ループ
      const safeDistance = 5.7;
      for (let iter = 0; iter < 3; iter++) {
        for (let i = 0; i < cubes.length; i++) {
          let offset = new THREE.Vector3(0, 0, 0);
          for (let j = 0; j < cubes.length; j++) {
            if (i === j) continue;
            let dx = cubes[i].position.x - cubes[j].position.x;
            let dz = cubes[i].position.z - cubes[j].position.z;
            let dist = Math.sqrt(dx * dx + dz * dz);
            if (dist < safeDistance && dist > 0) {
              let diff = safeDistance - dist;
              let repulse = diff * 0.2;
              offset.x += (dx / dist) * repulse;
              offset.z += (dz / dist) * repulse;
            }
          }
          cubes[i].position.x += offset.x;
          cubes[i].position.z += offset.z;
          cubes[i].position.x = THREE.MathUtils.clamp(cubes[i].position.x, gridXMin, gridXMax);
          cubes[i].position.z = THREE.MathUtils.clamp(cubes[i].position.z, gridZMin, gridZMax);
        }
      }
      
      renderer.render(scene, camera);
    }
    animate();
    
    // 画面リサイズ処理（アスペクト比更新）
    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener('resize', onResize);
    
    // 初回：リスタートボタン表示、開始メッセージ
    restartBtn.style.display = "inline-block";
    overlayMessage.innerText = "下のボタンをクリックしてゲーム開始";
    
    restartBtn.addEventListener('click', () => {
      score = 0;
      round = 1;
      scoreDisplay.innerText = "スコア: 0";
      restartBtn.style.display = "none";
      overlayMessage.innerText = "";
      gameIsRunning = true;
      startNewRound();
    });
  </script>
</body>
</html>
